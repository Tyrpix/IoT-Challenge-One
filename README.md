# How to Build
BBC micro:bit required and 'microbit-samples' folder

```
git clone https://github.com/lancaster-university/microbitsamples
```
Copy the main.cpp files to microbit-samples\source
Change into microbit-samples

Compile
```
yt clean
yt build
```

# How to Run
```
cp build/bbc-microbit-classic-gcc/source/microbit-samples-combined.hex /media/student/MICROBIT/
```

# COPY CAT
A copy the sequence game for the BBC micro:bit.

# Overview
The game displays a 'random' sequence of actions to be performed(copied) by the player. 
The sequence is displayed on the LED matrix and starts with 1 iteration (Level 1).
Each time the sequence is correctly copied, the total number of actions in the sequence is incremented by 1.
The game consists of 6 different actions and a neutral position;
1. Left Tilt
2. Right Tilt
3. Upward Tilt
4. Downward Tilt
5. Press A
6. Press B
Neutral postion is represented by a diamond shape in the center of the LED matrix.

# How to play
1. The player should hold the micro:bit face up
2. Press A or B to start when prompted by the LED matrix
3. The sequence will start after the countdown and the center diamond flashes
4. The player must remember the sequence of actions and perform them in the same order
5. If the player completes the correct actions, they move on to the next level
6. If the player performs an action incorrectly a sad face will appear on the LED matrix
7. The use can play again by shaking the micro:bit after prompted to 'shake'
8. Alternatively they can press A or B after prompted to 'shake' to end the game



# Performance

This program utilises the micro:bits’ ability to register inputs from the A and B buttons while, also determining the position of the accelerometer through the use of “Gestures”. The key element of the game is to reproduce these types of actions in the same order as displayed by the LED matrix.

The sequence of actions is generated by using uBit.random which returns a random integer between 0 and 5 (so 6 in total) and then stored in an array. The sequence is displayed based on the current level of the game which starts at 1, each action is equal to one of the 6 integers. 

The players movement actions are captured using getGesture() which updates the X and Y position of the accelerometer. This position is returned and then validated. The micro:bit event message bus knows when it is tilting left by the accelerometer position for example; MICROBIT_ACCELEROMETER_EVT_TILT_LEFT.

The players button presses are recorded using uBit.buttonA.isPressed(), uBit.buttonB.isPressed() which returns 1 if pressed, 0 otherwise. Both accelerometer and button events performed by the user are validated. This is achieved by comparing the index position of the action in the sequence array. The position in the array is indexed into by the current user inputs; sequence[userInputs]. The indexed value is compared with the action’s integer value. If equal the user completed the correct action however, if not the user fails and the game is over.

When the end of the code is reached the micro:bits’ fibre is released to enter a low power sleep mode. I took note that this fibre can be split and sperate fibres created using create_fibre(). This would have been useful if my game had required the micro:bit to keep track of simultaneous events and LED functions. However, my game displays a sequence on the LED matrix and then waits for events to occur which are responded to with a simple one to one action. 

